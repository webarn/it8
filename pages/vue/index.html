<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue知识点 | IT吧</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="前端知识体系收集,前端面试题,前端收集">
    <meta name="keywords" content="it8,it吧,前端知识体系,前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.f878aba8.css" as="style"><link rel="preload" href="/assets/js/app.51b2f07e.js" as="script"><link rel="preload" href="/assets/js/2.1834a619.js" as="script"><link rel="preload" href="/assets/js/25.7aa6dc6c.js" as="script"><link rel="prefetch" href="/assets/js/10.8c9829e6.js"><link rel="prefetch" href="/assets/js/11.68218080.js"><link rel="prefetch" href="/assets/js/12.b65b6dbf.js"><link rel="prefetch" href="/assets/js/13.66cb7ca3.js"><link rel="prefetch" href="/assets/js/14.a76f255b.js"><link rel="prefetch" href="/assets/js/15.9ba0ff33.js"><link rel="prefetch" href="/assets/js/16.bdee8aff.js"><link rel="prefetch" href="/assets/js/17.159879a6.js"><link rel="prefetch" href="/assets/js/18.7143d0ea.js"><link rel="prefetch" href="/assets/js/19.e36e21f0.js"><link rel="prefetch" href="/assets/js/20.d53c4a59.js"><link rel="prefetch" href="/assets/js/21.2f11f50b.js"><link rel="prefetch" href="/assets/js/22.bf293c33.js"><link rel="prefetch" href="/assets/js/23.110ba1c5.js"><link rel="prefetch" href="/assets/js/24.c2c4fc00.js"><link rel="prefetch" href="/assets/js/26.770c3448.js"><link rel="prefetch" href="/assets/js/3.6a29b6ef.js"><link rel="prefetch" href="/assets/js/4.524697e6.js"><link rel="prefetch" href="/assets/js/5.792cd270.js"><link rel="prefetch" href="/assets/js/6.9513fcf8.js"><link rel="prefetch" href="/assets/js/7.76cd3b51.js"><link rel="prefetch" href="/assets/js/8.3e5d344b.js"><link rel="prefetch" href="/assets/js/9.a75cd5c7.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f878aba8.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/home-icon.png" alt="IT吧" class="logo"> <span class="site-name can-hide">IT吧</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><!----> <span class="title" style="display:;">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/base/" class="nav-link">基础知识</a></li><li class="dropdown-item"><!----> <a href="/javascript/diy/" class="nav-link">原理实现</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><a href="/pages/vue/" aria-current="page" class="link-title router-link-exact-active router-link-active">框架</a> <span class="title" style="display:none;">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/vue/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Vue</a></li><li class="dropdown-item"><!----> <a href="/pages/webpack/" class="nav-link">Webpack</a></li></ul></div></div><div class="nav-item"><a href="/pages/letcode/" class="nav-link">算法</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><!----> <span class="title" style="display:;">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/base/" class="nav-link">基础知识</a></li><li class="dropdown-item"><!----> <a href="/javascript/diy/" class="nav-link">原理实现</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><a href="/pages/vue/" aria-current="page" class="link-title router-link-exact-active router-link-active">框架</a> <span class="title" style="display:none;">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/vue/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Vue</a></li><li class="dropdown-item"><!----> <a href="/pages/webpack/" class="nav-link">Webpack</a></li></ul></div></div><div class="nav-item"><a href="/pages/letcode/" class="nav-link">算法</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/vue/" aria-current="page" class="active sidebar-link">Vue知识点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/vue/#mvc-和-mvvm-区别" class="sidebar-link">MVC 和 MVVM 区别</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#为什么-data-是一个函数" class="sidebar-link">为什么 data 是一个函数</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#vue-组件通讯有哪几种方式" class="sidebar-link">Vue 组件通讯有哪几种方式</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#vue-的生命周期方法有哪些-一般在哪一步发请求" class="sidebar-link">Vue 的生命周期方法有哪些 一般在哪一步发请求</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#异步请求在哪一步发起" class="sidebar-link">异步请求在哪一步发起？</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#v-if-和-v-show的区别" class="sidebar-link">v-if 和 v-show的区别</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#怎样理解-vue-的单向数据流" class="sidebar-link">怎样理解 Vue 的单向数据流</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#computed-和-watch-的区别和运用的场景" class="sidebar-link">computed 和 watch 的区别和运用的场景</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#v-if-与-v-for-为什么不建议一起使用" class="sidebar-link">v-if 与 v-for 为什么不建议一起使用</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#vue2-0-响应式数据的原理" class="sidebar-link">Vue2.0 响应式数据的原理</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#vue-的父子组件生命周期钩子函数执行顺序" class="sidebar-link">Vue 的父子组件生命周期钩子函数执行顺序</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#v-model-原理" class="sidebar-link">v-model 原理</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#你都做过哪些-vue-的性能优化" class="sidebar-link">你都做过哪些 Vue 的性能优化</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#vue-mixin-的使用场景和原理" class="sidebar-link">Vue.mixin 的使用场景和原理</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#动态给-vue-的-data-添加一个新的属性时会发生什么-怎样解决" class="sidebar-link">动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#响应式步骤" class="sidebar-link">响应式步骤</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#slot-的理解-slot-使用场景" class="sidebar-link">slot 的理解？slot 使用场景</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#keep-alive-的理解" class="sidebar-link">keep-alive 的理解？</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#vue-常用的修饰符" class="sidebar-link">Vue 常用的修饰符</a></li><li class="sidebar-sub-header"><a href="/pages/vue/#vue-的-diff-算法" class="sidebar-link">vue 的 diff 算法？</a></li></ul></li><li><a href="/pages/webpack/" class="sidebar-link">Webpack</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper bg-style-1"><!----> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">
          Vue知识点
        </h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="mvc-和-mvvm-区别"><a href="#mvc-和-mvvm-区别" class="header-anchor">#</a> MVC 和 MVVM 区别</h2> <p>MVC,MVVM 是前端架构模式</p> <h4 id="mvc"><a href="#mvc" class="header-anchor">#</a> MVC</h4> <ul><li>Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据</li> <li>View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的</li> <li>Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据</li></ul> <p><strong><code>MVC</code> 的思想：一句话描述就是 <code>Controller</code> 负责将 <code>Model</code> 的数据用 <code>View</code> 显示出来，换句话说就是在 <code>Controller</code> 里面把 <code>Model</code> 的数据赋值给 <code>View。</code></strong></p> <h4 id="mvvm"><a href="#mvvm" class="header-anchor">#</a> MVVM</h4> <p>MVVM 新增了 VM 类</p> <ul><li>ViewModel 层：做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</li></ul> <h4 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h4> <p>MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应 Vue 数据驱动的思想）</p> <blockquote><p><strong>Vue 并没有完全遵循 MVVM 的思想 这一点官网自己也有说明: 严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 提供了$refs 这个属性，让 Model 可以直接操作 View，违反了这一规定，所以说 Vue 没有完全遵循 MVVM。</strong></p></blockquote> <h2 id="为什么-data-是一个函数"><a href="#为什么-data-是一个函数" class="header-anchor">#</a> 为什么 data 是一个函数</h2> <blockquote><p>在我们定义好一个组件的时候，vue 最终都会通过 Vue.extend()构成组件实例, 组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果</p></blockquote> <h2 id="vue-组件通讯有哪几种方式"><a href="#vue-组件通讯有哪几种方式" class="header-anchor">#</a> Vue 组件通讯有哪几种方式</h2> <ol><li><code>props</code> and <code>$emit</code> 父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件来做到的</li> <li><code>$children</code> and <code>$parent</code> 获取当前组件的父组件和当前组件的子组件</li> <li><code>$attrs</code> and <code>$listeners</code> A-&gt;B-&gt;C。Vue 2.4 开始提供了<code>$attrs</code> 和 <code>$listeners</code> 来解决这个问题</li> <li><code>provide</code> and <code>inject</code> 简单来说就是父组件中通过 provide 来提供变量, 然后再子组件中通过 inject 来注入变量。
<blockquote><p>这里不论子组件嵌套有多深, 只要调用了 inject 那么就可以注入 provide 中的数据，而不局限于只能从当前父组件的 props 属性中回去数据</p></blockquote></li> <li><code>$refs</code> 获取组件实例</li> <li><code>eventBus</code> 兄弟组件数据传递 这种情况下可以使用事件总线的方式</li> <li><code>vuex</code> 状态管理</li></ol> <h2 id="vue-的生命周期方法有哪些-一般在哪一步发请求"><a href="#vue-的生命周期方法有哪些-一般在哪一步发请求" class="header-anchor">#</a> Vue 的生命周期方法有哪些 一般在哪一步发请求</h2> <blockquote><p>Vue 生命周期分为 4 个阶段,每个阶段分为 前后:</p></blockquote> <ol><li><code>beforeCreate</code>:
<blockquote><p>创建前, 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问.</p></blockquote></li> <li><code>create</code>:
<blockquote><p>创建后 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el,如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom.</p></blockquote></li> <li><code>beforeMount</code>:
<blockquote><p>挂载前 在挂载开始之前被调用：相关的 render 函数首次被调用。</p></blockquote></li> <li><code>mount</code>:
<blockquote><p>挂载后 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点.</p></blockquote></li> <li><code>beforeUpdate</code>:
<blockquote><p>更新前 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</p></blockquote></li> <li><code>updated</code>:
<blockquote><p>更新后 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。</p></blockquote></li> <li><code>beforeDestroy</code>:
<blockquote><p>销毁前 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。</p></blockquote></li> <li><code>destroyed</code>:
<blockquote><p>销毁后 Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</p></blockquote></li> <li>activated:
<blockquote><p><code>keep-alive</code> 专属，组件被激活时调用</p></blockquote></li> <li>deactivated:
<blockquote><p><code>keep-alive</code> 专属，组件被销毁时调用</p></blockquote></li></ol> <h2 id="异步请求在哪一步发起"><a href="#异步请求在哪一步发起" class="header-anchor">#</a> 异步请求在哪一步发起？</h2> <p>可以在钩子函数 <code>created、beforeMount、mounted</code> 中进行异步请求，因为在这三个钩子函数中，<code>data</code> 已经创建，可以将服务端端返回的数据进行赋值。</p> <p>如果异步请求不需要依赖 Dom 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p> <div class="language- extra-class"><pre><code>1. 能更快获取到服务端数据，减少页面 loading 时间；
2. ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；
</code></pre></div><h2 id="v-if-和-v-show的区别"><a href="#v-if-和-v-show的区别" class="header-anchor">#</a> <code>v-if</code> 和 <code>v-show</code>的区别</h2> <p><code>v-if</code> 在编译过程中会被转化成三元表达式,条件不满足时不渲染此节点。 <strong>适用于在运行时很少改变条件，不需要频繁切换条件的场景</strong> <code>v-show</code> 会被编译成指令，条件不满足时控制样式将对应节点隐藏 <code>（display:none）</code> <strong>适用于需要非常频繁切换条件的场景</strong></p> <h2 id="怎样理解-vue-的单向数据流"><a href="#怎样理解-vue-的单向数据流" class="header-anchor">#</a> 怎样理解 <code>Vue</code> 的单向数据流</h2> <blockquote><p>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p></blockquote> <h2 id="computed-和-watch-的区别和运用的场景"><a href="#computed-和-watch-的区别和运用的场景" class="header-anchor">#</a> <code>computed</code> 和 <code>watch</code> 的区别和运用的场景</h2> <h4 id="computed"><a href="#computed" class="header-anchor">#</a> computed</h4> <blockquote><p>计算属性, 依赖其他属性计算值, 返回值挂载到 vue 实例上, 带有缓存功能. 里面不能有异步操作.</p></blockquote> <blockquote><p><code>computed</code> 本身是个懒执行, 如果本渲染周期内没有使用该值,则不执行计算, 如果其依赖属性发生变化, 则会通知 <code>watcher</code>, <code>watcher</code>通过查看 dep 里是否有引用, 如果没有,则不计算, 有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染</p></blockquote> <h4 id="watch"><a href="#watch" class="header-anchor">#</a> watch</h4> <blockquote><p>监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。 有<code>handler</code>, <code>immediate</code>, <code>deep</code>属性. 依赖于数据已在 vue 实例上来监听.</p></blockquote> <h2 id="v-if-与-v-for-为什么不建议一起使用"><a href="#v-if-与-v-for-为什么不建议一起使用" class="header-anchor">#</a> v-if 与 v-for 为什么不建议一起使用</h2> <blockquote><p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中</p></blockquote> <h2 id="vue2-0-响应式数据的原理"><a href="#vue2-0-响应式数据的原理" class="header-anchor">#</a> Vue2.0 响应式数据的原理</h2> <p>整体思路是数据劫持+观察者模式</p> <blockquote><p>对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher（依赖收集），当属性变化后会通知自己对应的 watcher 去更新(派发更新)。</p></blockquote> <ol><li><p>vue 响应式是依据 mvvm 模式理念来实现的, 主要核心为 observe 和 complice 当我们 new Vue 的时候, initMixin 函数会在 vue 原型上 挂载一个 _init 方法. 并且把实例的参数传给 options.</p></li> <li><p>然后经过 initState 方法 来对数据扩展处理, 包括 prop, methods, data,computed,watch 进行 Observe 处理,并把数据挂载到 vm 上, 后面可以直接 this. 使用.</p></li> <li><p>observe 会判断数据是 Object 还是 Array, 并创建一个 Dep 实例, 如果是 Object 便进行递归遍历, 把所有的值都通过 Object.defineProperty() 方法添加上 get set 方法. 如果为 Array 数组,将会通过数组方法重写的形式,来添加方法.</p></li> <li><p>在 $mount 解析模板的时候 首次渲染触发 watcher 然后触发 get 方法, 在 get 里收集依赖, 每个属性都有自己的 dep 实例 来保存 自己的 watch. 在 set 里触发数据更新 dep.notify ,遍历该数据依赖列表,通知所有相关的 watcher 进行视图更新</p></li></ol> <p>代码如下:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
  <span class="token comment">// 观测值</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">walk</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对象上的所有属性依次进行观测</span>
    <span class="token keyword">let</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> value <span class="token operator">=</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// Object.defineProperty数据劫持核心 兼容性在ie9以及以上</span>
<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">observe</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归关键</span>
  <span class="token comment">// --如果value还是一个对象会继续走一遍odefineReactive 层层遍历一直到value不是对象才停止</span>
  <span class="token comment">//   思考？如果Vue数据嵌套层级过深 &gt;&gt;性能会受影响</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'获取值'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">//需要做依赖收集过程 这里代码没写出来</span>
      <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">===</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'设置值'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//需要做派发更新过程 这里代码没写出来</span>
      value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果传过来的是对象或者数组 进行属性劫持</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Object]'</span> <span class="token operator">||</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><h2 id="vue-的父子组件生命周期钩子函数执行顺序"><a href="#vue-的父子组件生命周期钩子函数执行顺序" class="header-anchor">#</a> Vue 的父子组件生命周期钩子函数执行顺序</h2> <h4 id="加载渲染过程"><a href="#加载渲染过程" class="header-anchor">#</a> 加载渲染过程</h4> <blockquote><p>父 <code>beforeCreate</code>-&gt;父 <code>created</code>-&gt;父 <code>beforeMount</code>-&gt;子 <code>beforeCreate</code>-&gt;子 <code>created</code>-&gt;子 <code>beforeMount</code>-&gt;子 <code>mounted</code>-&gt;父 <code>mounted</code></p></blockquote> <h2 id="v-model-原理"><a href="#v-model-原理" class="header-anchor">#</a> <code>v-model</code> 原理</h2> <p>v-model 只是语法糖而已</p> <p>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p> <ul><li>text 和 textarea 元素使用 value property 和 input 事件；</li> <li>checkbox 和 radio 使用 checked property 和 change 事件；</li> <li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul> <p>在普通标签上</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;sth&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>  <span class="token comment">//这一行等于下一行</span>
<span class="token operator">&lt;</span>input v<span class="token operator">-</span>bind<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;sth&quot;</span> v<span class="token operator">-</span>on<span class="token operator">:</span>input<span class="token operator">=</span><span class="token string">&quot;sth = $event.target.value&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在组件上</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>currency<span class="token operator">-</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;price&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>currentcy<span class="token operator">-</span>input<span class="token operator">&gt;</span>
<span class="token comment">// 上行代码是下行的语法糖</span>
<span class="token comment">//  &lt;currency-input :value=&quot;price&quot; @input=&quot;price = arguments[0]&quot;&gt;&lt;/currency-input&gt;</span>

<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 子组件定义 <span class="token operator">--</span><span class="token operator">&gt;</span>
Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'currency-input'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
 template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
  &lt;span&gt;
   &lt;input
    ref=&quot;input&quot;
    :value=&quot;value&quot;
    @input=&quot;$emit('input', $event.target.value)&quot;
   &gt;
  &lt;/span&gt;
 </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
 props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'value'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="你都做过哪些-vue-的性能优化"><a href="#你都做过哪些-vue-的性能优化" class="header-anchor">#</a> 你都做过哪些 Vue 的性能优化</h2> <h4 id="代码层面的优化"><a href="#代码层面的优化" class="header-anchor">#</a> 代码层面的优化</h4> <ul><li>对象层级不要过深，否则性能就会差</li> <li>不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）</li> <li>v-if 和 v-show 区分使用场景</li> <li>computed 和 watch 区分使用场景</li> <li>v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if</li> <li>大数据列表和表格性能优化-虚拟列表/虚拟表格</li> <li>防止内部泄漏，组件销毁后把全局变量和事件销毁</li> <li>图片懒加载</li> <li>路由懒加载</li> <li>第三方插件的按需引入</li> <li>适当采用 keep-alive 缓存组件</li> <li>防抖、节流运用</li> <li>服务端渲染 SSR or 预渲染</li></ul> <h4 id="webpack-层面的优化"><a href="#webpack-层面的优化" class="header-anchor">#</a> Webpack 层面的优化</h4> <ul><li>Webpack 对图片进行压缩</li> <li>减少 ES6 转为 ES5 的冗余代码</li> <li>提取公共代码</li> <li>模板预编译</li> <li>提取组件的 CSS</li> <li>优化 SourceMap</li> <li>构建结果输出分析</li> <li>Vue 项目的编译优化</li></ul> <h4 id="基础的-web-技术的优化开启-gzip-压缩"><a href="#基础的-web-技术的优化开启-gzip-压缩" class="header-anchor">#</a> 基础的 Web 技术的优化开启 gzip 压缩</h4> <ul><li>浏览器缓存</li> <li>CDN 的使用</li> <li>使用 Chrome Performance 查找性能瓶颈</li></ul> <h2 id="vue-mixin-的使用场景和原理"><a href="#vue-mixin-的使用场景和原理" class="header-anchor">#</a> Vue.mixin 的使用场景和原理</h2> <blockquote><p>在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立，可以通过 Vue 的 mixin 功能抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始化时会调用 mergeOptions 方法进行合并，采用策略模式针对不同的属性进行合并。当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。</p></blockquote> <h4 id="合并策略-parent-childer"><a href="#合并策略-parent-childer" class="header-anchor">#</a> 合并策略: parent -&gt; childer</h4> <ul><li><strong>数据对象会进行递归处理, 并在发生冲突时以组件数据优先。</strong></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myMixin <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      message<span class="token operator">:</span> <span class="token string">'hello Mixin'</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    methods<span class="token operator">:</span><span class="token punctuation">{</span>
      <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        consol
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  mixins<span class="token operator">:</span> <span class="token punctuation">[</span>myMixin<span class="token punctuation">]</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span>
    message<span class="token operator">:</span> <span class="token string">'Hello Vue!'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello Vue!</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><ul><li>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> mixin <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'混入对象的钩子被调用'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  mixins<span class="token operator">:</span> <span class="token punctuation">[</span>mixin<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'组件钩子被调用'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 先调用 mixin 的created , 然后在调用 实例的 created: 混入对象的钩子被调用 -&gt; 组件钩子被调用</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ul><li>值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> mixin <span class="token operator">=</span> <span class="token punctuation">{</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">conflicting</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'from mixin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  mixins<span class="token operator">:</span> <span class="token punctuation">[</span>mixin<span class="token punctuation">]</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">bar</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">conflicting</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'from self'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

vm<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// =&gt; &quot;foo&quot;</span>
vm<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// =&gt; &quot;bar&quot;</span>
vm<span class="token punctuation">.</span><span class="token function">conflicting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// =&gt; &quot;from self&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><ul><li>替换型策略有 props、methods、inject、computed，就是将新的同名参数替代旧的参数</li> <li>合并型策略是 data, 通过 set 方法进行合并和重新赋值</li> <li>队列型策略有生命周期函数和 watch，原理是将函数存入一个数组，然后正序遍历依次执行</li> <li>叠加型有 component、directives、filters，通过原型链进行层层的叠加</li></ul> <h2 id="动态给-vue-的-data-添加一个新的属性时会发生什么-怎样解决"><a href="#动态给-vue-的-data-添加一个新的属性时会发生什么-怎样解决" class="header-anchor">#</a> 动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？</h2> <h4 id="结果"><a href="#结果" class="header-anchor">#</a> 结果</h4> <p>值可以正常打印出来, 但是并不会生成响应式.</p> <h4 id="分析"><a href="#分析" class="header-anchor">#</a> 分析</h4> <p><code>vue2</code> 是用过 <code>Object.defineProperty</code> 实现数据响应式, 是实例化的时候添加的 <code>get</code>, <code>set</code>属性, 所以可以拦截到数据的改变, 但是新追加的属性,在实例化的时候并没有经过<code>Object.defineProperty</code>拦截, 所以不能生成响应式数据.</p> <h4 id="解决"><a href="#解决" class="header-anchor">#</a> 解决</h4> <ul><li>Vue.set()</li> <li>Object.assign()</li> <li>$forcecUpdated()</li></ul> <h2 id="响应式步骤"><a href="#响应式步骤" class="header-anchor">#</a> 响应式步骤</h2> <ol><li>new Vue 的时候通过一个 <code>Observer</code> 方法来通过递归遍历所有的 data 属性, 通过 <code>Object.defineProperty</code> 来添加 <code>get</code>, <code>set</code>属性;</li> <li>通过 <code>Compile</code> 方法来编译模板, 找到其中动态绑定的数据, 并从 <code>data</code> 中取出并初始化视图;</li> <li>在 <code>vm.$mount</code> 初始化的时候通过 <code>Watcher</code> 会触发 <code>data</code> 中的 <code>get</code> 方法;</li> <li>在取 <code>data</code> 中的数据数时候, 触发 <code>get</code> 方法, <code>get</code>方法里创建一个 <code>Dep</code> 方法来收集依赖, 记录那里用到了该值;</li> <li>如果该值更新, 触发 <code>set</code>方法, <code>set</code>方法通过 <code>Dep</code> 方法通知 <code>Watcher</code> 方法, <code>Watcher</code> 通过 <code>Updated</code> 触发视图更新;</li></ol> <h2 id="slot-的理解-slot-使用场景"><a href="#slot-的理解-slot-使用场景" class="header-anchor">#</a> slot 的理解？slot 使用场景</h2> <p><code>slot</code>插槽可以理解为占位符: 当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中 slot 位置），作为承载分发内容的出口</p> <h4 id="分类"><a href="#分类" class="header-anchor">#</a> 分类</h4> <ul><li>默认插槽</li> <li>具名插槽</li> <li>作用域插槽: 子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件 v-slot 接受的对象上
子组件<div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>footer<span class="token punctuation">&quot;</span></span> <span class="token attr-name">testProps</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>子组件的值<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">&gt;</span></span>没传footer插槽<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div>父组件<div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- 把v-slot的值指定为作⽤域上下⽂对象 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>slotProps<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    来⾃⼦组件数据：{{slotProps.testProps}}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">#default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>slotProps<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    来⾃⼦组件数据：{{slotProps.testProps}}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ul> <h4 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h4> <blockquote><p>slot 本质上是返回 VNode 的函数，一般情况下，Vue 中的组件要渲染到页面上需要经过 template -&gt; render function -&gt; VNode -&gt; DOM 过程</p></blockquote> <h2 id="keep-alive-的理解"><a href="#keep-alive-的理解" class="header-anchor">#</a> keep-alive 的理解？</h2> <p><code>keep-alive</code> 作用是缓存页面或组件切换不被销毁,保存在内存中的内置组件
有以下属性:</p> <ul><li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存</li> <li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存</li> <li><code>max</code> - 数字。最多可以缓存多少组件实例</li></ul> <p>两个生命周期: <code>activated</code> <code>deactivated</code></p> <ul><li><p>首次进入组件时：<code>beforeRouteEnter</code> &gt; <code>beforeCreate</code> &gt; <code>created</code> &gt; <code>mounted</code> &gt; <code>activated</code> &gt; ... ... &gt; <code>beforeRouteLeave</code> &gt; <code>deactivated</code></p></li> <li><p>再次进入组件时：<code>beforeRouteEnter</code> &gt; <code>activated</code> &gt; ... ... &gt; <code>beforeRouteLeave</code> &gt; <code>deactivated</code></p></li></ul> <h2 id="vue-常用的修饰符"><a href="#vue-常用的修饰符" class="header-anchor">#</a> Vue 常用的修饰符</h2> <p>主要分为五类:</p> <div class="language- extra-class"><pre><code>1. 表单修饰符
2. 事件修饰符
3. 鼠标按键修饰符
3. 键值修饰符
4. v-bind修饰符
</code></pre></div><h4 id="表单修饰符"><a href="#表单修饰符" class="header-anchor">#</a> 表单修饰符</h4> <ul><li><code>lazy</code> - 在我们填完信息，光标离开标签的时候，才会将值赋予给 value，也就是在 change 事件之后再进行信息同步</li></ul> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-model.lazy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{value}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li><code>trim</code> - 自动过滤用户输入的首空格字符，而中间的空格不会过滤</li></ul> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-model.trim</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><code>number</code> - 自动将用户的输入值转为数值类型，但如果这个值无法被 <code>parseFloat</code> 解析，则会返回原来的值</li></ul> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model.number</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>age<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>number<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="事件修饰符"><a href="#事件修饰符" class="header-anchor">#</a> 事件修饰符</h4> <ul><li><code>stop</code> - 阻止了事件冒泡，相当于调用了 <code>event.stopPropagation</code> 方法</li> <li><code>prevent</code> - 阻止了事件的默认行为，相当于调用了 <code>event.preventDefault</code> 方法</li> <li><code>self</code> - 只当在 <code>event.target</code> 是当前元素自身时触发处理函数</li> <li><code>once</code> - 绑定了事件以后只能触发一次，第二次就不会触发</li> <li><code>capture</code> - 使事件触发从包含这个元素的顶层开始往下触发</li> <li><code>passive</code> - 在移动端，当我们在监听元素滚动事件的时候，会一直触发 onscroll 事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给 onscroll 事件整了一个.lazy 修饰符</li> <li><code>native</code> - 让组件变成像 html 内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件</li></ul> <h2 id="vue-的-diff-算法"><a href="#vue-的-diff-算法" class="header-anchor">#</a> vue 的 diff 算法？</h2> <p><code>diff</code> 算法是一种通过同层的树节点进行比较的高效算法
其有两个特点：</p> <ul><li>比较只会在同层级进行, 不会跨层级比较</li> <li>在 diff 比较的过程中，循环从两边向中间比较</li></ul> <p><a href="https://www.bilibili.com/video/BV1Ph41117hq?p=1" target="_blank" rel="noopener noreferrer">视频动画讲解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></div> <!----> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2021/12/02, 12:17:20</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><!----> <a href="/pages/webpack/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Webpack</div></a></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/pages/webpack/">Webpack</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> <!----></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.51b2f07e.js" defer></script><script src="/assets/js/2.1834a619.js" defer></script><script src="/assets/js/25.7aa6dc6c.js" defer></script>
  </body>
</html>
